# -*- coding: utf-8 -*-
"""Final Project Red Wine.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Uj8e-QJiG7AIV245DSzNhUIhWRBlH64L
"""

#1 import the data

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns

df=pd.read_csv('/content/winequality-red.csv', sep=';')

#2 Check labelled /unlabelled ,find the target column,target (numerical or categoical),Regression or classification algthm

print(df)

df.shape

df.head(n=2)

df.tail(n=10)

df.quality.unique()

df['residual sugar'].unique().max()

# Question: how to find this sweetest wine?

df.describe()

df.info()

df.isna().sum()

"""# **Labelled Data**; **Target Column 'quality'**; **numerical**; use **regression** """

#3 Data Exploaration(shape,describe,columns,info)
# Missing values
# Inconsistent Values
# Outliers
# Data types consistent
# Duplicate
# Dataset balanced/imblanced
# Data cleaning

df.describe(include = 'all')

df['quality'].describe()

df.mean()

df.max()

df.min()

df.median()

df.duplicated().sum()

df[df.duplicated()]

df.duplicated('volatile acidity').sum()

print('Total Duplicates = '+ str(df.duplicated().sum()))

df.isnull().sum()

df.duplicated().any()

#4 Visualaization ( Explore my datasets by charts)

df.corr()

df.corr()['quality']

plt.figure(figsize=(15,10))
sns.heatmap(df.corr(),linewidth=0.5,annot=True, center=0, cmap='GnBu')

sns.countplot(x = df['quality']).set(title = 'Quality Distribution', 
                                       xlabel = 'Quality', 
                                       ylabel = 'Count');

sns.distplot(df['quality'])





sns.boxplot(data = df['quality'])

"""# many outliers of teh residual sugar. shall we remove?"""

sns.boxplot(df['alcohol'])

sns.boxplot(df['chlorides'])

"""# Chlorides also have outliers problems"""

sns.boxplot(df['citric acid'])

sns.boxplot(df['density'])

"""# outliers in density"""

sns.boxplot(df['fixed acidity'])

"""#outliers in fixed acidity"""

sns.boxplot(df['free sulfur dioxide'])

sns.boxplot(df['pH'])

sns.boxplot(df['sulphates'])

sns.boxplot(df['total sulfur dioxide'])

sns.boxplot(df['volatile acidity'])

plt.figure(figsize=(20,10))
df.boxplot()

sns.lineplot(data = df, x = 'quality', y = 'density')

plt.figure(figsize=(5,5))
sns.scatterplot(data = df, x = 'quality', y = 'citric acid')

!pip install sweetviz

import sweetviz as sv

advert_report = sv.analyze(df)

advert_report.show_html('Advertising.html')

advert_report.show_notebook()

#5 Feature Engineering (Feature Importance,convert categorical data by using encoding,Feature Scaling(Normalization)

#6 Split the data train and test

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn import metrics
from sklearn.preprocessing import StandardScaler as sc

#6 Create the model

x = df.iloc[:,:11]
y = df['quality']

x_train, x_test, y_train, y_test= train_test_split(x, y, test_size= 0.3, random_state=100)

#7 Apply the model to the train data

mlr= LinearRegression()  
mlr.fit(x_train, y_train)

# 8 Trained model is ready

#Printing the model coefficients
print(mlr.intercept_)
# pair the feature names with the coefficients
list(zip(x, mlr.coef_))

#9 Test the trained model by the test data

y_pred_mlr= mlr.predict(x_test)  
x_pred_mlr= mlr.predict(x_train)

print("Prediction for test set: {}".format(y_pred_mlr))

mlr_diff = pd.DataFrame({'Actual value': y_test, 'Predicted value': y_pred_mlr})
mlr_diff

#10 Print the evaluation metrics
#(regress=MSE,MAE,R2)
#(classification-Confusion Matrix ,precision,ROC)

print('R squared value of the model: {:.2f}'.format(mlr.score(x,y)*100))

meanAbErr = metrics.mean_absolute_error(y_test, y_pred_mlr)
meanSqErr = metrics.mean_squared_error(y_test, y_pred_mlr)
rootMeanSqErr = np.sqrt(metrics.mean_squared_error(y_test, y_pred_mlr))

print('Mean Absolute Error:', meanAbErr)
print('Mean Square Error:', meanSqErr)
print('Root Mean Square Error:', rootMeanSqErr)